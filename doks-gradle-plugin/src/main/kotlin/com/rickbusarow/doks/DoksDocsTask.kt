/*
 * Copyright (C) 2025 Rick Busarow
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.rickbusarow.doks

import com.rickbusarow.doks.internal.DoksEngine
import com.rickbusarow.doks.internal.Rule
import com.rickbusarow.doks.internal.RuleSerializable
import com.rickbusarow.doks.internal.Rules
import com.rickbusarow.doks.internal.psi.SampleRequestSerializable
import com.rickbusarow.doks.internal.psi.SampleResult
import com.rickbusarow.doks.internal.stdlib.createSafely
import kotlinx.serialization.json.Json
import org.gradle.api.NamedDomainObjectContainer
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.FileType
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.model.ObjectFactory
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Classpath
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.Optional
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.options.Option
import org.gradle.work.ChangeType
import org.gradle.work.Incremental
import org.gradle.work.InputChanges
import org.gradle.workers.WorkAction
import org.gradle.workers.WorkParameters
import org.gradle.workers.WorkerExecutor
import java.io.File
import javax.inject.Inject

/**
 * Either checks or fixes/updated documentation files for a given [DoksSet].
 *
 * @since 0.1.0
 */
public abstract class DoksDocsTask @Inject constructor(
  private val workerExecutor: WorkerExecutor,
  objects: ObjectFactory
) : DoksTask("Updates documentation files") {
  /**
   * This JSON file is generated by the `doksParse` task associated with this source set. It
   * is a map of fully-qualified names of code samples to their corresponding code snippets.
   *
   * @since 0.1.0
   */
  @get:Optional
  @get:InputFile
  public abstract val samplesMapping: RegularFileProperty

  /**
   * The directory where the updated documentation files
   * will be written during the execution of this task.
   *
   * This property serves as a workaround for the limitations of incremental tasks, which can't
   * have the same inputs as their outputs. Since this task is essentially a "formatting" task
   * that modifies input files, we can't use the actual input files as outputs without risking that
   * they will be deleted by Gradle in case of a binary change to the plugin or build environment.
   * Instead, we use this property to declare a separate directory as the output of this task.
   *
   * Any time this task writes changes to an input file, it also creates a stub file with
   * the same relative path inside the docsShadow directory. During the next incremental
   * build, the task will only need to update the real input files that have changed
   * since the last build, and the contents of the docsShadow directory will be ignored.
   *
   * Note that the contents of the docsShadow directory are not meant to be used by
   * other tasks or processes, and should not be relied on as a source of truth for the
   * documentation files. Its sole purpose is to allow this task to run incrementally
   * without interfering with other tasks that might need to use the same files.
   *
   * @since 0.1.0
   */
  @get:OutputDirectory
  internal abstract val docsShadow: DirectoryProperty

  /**
   * A file collection containing all the Markdown files included in this source set.
   * These files are not generated, but rather describe the properties and code in
   * the source set. They are checked to ensure that they are up-to-date with the
   * source code and other configuration files. If the properties or code they're
   * describing have changed, the markdown files are updated to reflect those changes.
   *
   * @since 0.1.0
   */
  @get:Incremental
  @get:InputFiles
  @get:PathSensitive(PathSensitivity.RELATIVE)
  public abstract val docs: ConfigurableFileCollection

  @get:Input
  internal abstract val ruleBuilders: NamedDomainObjectContainer<RuleBuilderScope>

  private val autoCorrectProperty: Property<Boolean> = objects.property(Boolean::class.java)
    .convention(false)

  /**
   * If true, Doks will automatically fix any out-of-date documentation.
   *
   * @since 0.1.0
   */
  @set:Option(
    option = "autoCorrect",
    description = "If true, Doks will automatically fix any out-of-date documentation."
  )
  public var autoCorrect: Boolean
    @Input
    get() = autoCorrectProperty.get()
    set(value) = autoCorrectProperty.set(value)

  /**
   * Dependencies for normal (non-PSI) Doks parsing
   *
   * @since 0.3.0
   */
  @get:InputFiles
  @get:Classpath
  internal abstract val doksClasspath: ConfigurableFileCollection

  /** @since 0.1.0 */
  @TaskAction
  public fun execute(inputChanges: InputChanges) {

    val queue = workerExecutor.classLoaderIsolation {
      it.classpath.setFrom(doksClasspath)
    }

    val changes = inputChanges.getFileChanges(docs)
      .mapNotNull { fileChange ->
        fileChange.file.takeIf {
          fileChange.changeType != ChangeType.REMOVED && fileChange.fileType == FileType.FILE
        }
      }

    val shadow by lazy(LazyThreadSafetyMode.NONE) { docsShadow.get().asFile }

    if (changes.isNotEmpty()) {
      shadow.mkdirs()
    }

    changes.forEach { file ->

      val relative = file.relativeTo(shadow)
        .normalize()
        .path
        .removePrefix(shadow.path)
        .split(File.separator)
        .dropWhile { it == ".." && it.isNotBlank() }
        .joinToString(File.separator)
        .replace(file.extension, "txt")

      queue.submit(DocsWorkAction::class.java) { params ->
        params.samplesMapping.set(samplesMapping)
        params.rules.set(ruleBuilders.map(RuleBuilderScope::toRule))
        params.autoCorrect.set(autoCorrect)
        params.file.set(file)
        params.outFile.set(docsShadow.get().file(relative))
      }
    }

    // block execution of any other tasks in this project until this work is complete
    // queue.await()
  }

  internal interface DocsParameters : WorkParameters {

    val samplesMapping: RegularFileProperty

    val rules: ListProperty<Rule>

    val autoCorrect: Property<Boolean>

    /**
     * The real doc file to be parsed/synced.
     *
     * @since 0.0.1
     */
    val file: RegularFileProperty

    /**
     * The shadowed file to be created by this worker. Its name should be
     * a relative path of the associated real file, and the content should
     * be a hash code, though it could really be anything or nothing.
     *
     * @since 0.0.1
     */
    val outFile: RegularFileProperty
  }

  internal abstract class DocsWorkAction : WorkAction<DocsParameters> {
    override fun execute() {

      val json = Json {
        prettyPrint = true
        allowStructuredMapKeys = true
      }

      val resultsByRequest = parameters.samplesMapping.orNull
        ?.asFile
        ?.readText()
        ?.takeIf { it.isNotBlank() }
        ?.let { jsonString ->
          json.decodeFromString<Map<SampleRequestSerializable, SampleResult>>(
            jsonString
          )
        }
        .orEmpty()

      val resultsByRequestHash = resultsByRequest
        .mapKeys { (request, _) -> request.hashCode() }

      val rules = parameters.rules.get()
        .map { builder ->
          val withSamples = builder.replacement.replace("\u200B(-?\\d+)\u200B".toRegex()) { mr ->
            resultsByRequestHash.getValue(mr.groupValues[1].toInt()).content
          }
            .let {
              if (it != builder.replacement) {
                Regex.escapeReplacement(it)
              } else {
                it
              }
            }

          RuleSerializable(
            name = builder.name,
            regex = builder.regex,
            replacement = withSamples
          )
        }
        .associateBy { it.name }

      val engine = DoksEngine(
        ruleCache = Rules(rules),
        autoCorrect = parameters.autoCorrect.get()
      )

      val file = parameters.file.get().asFile

      val result = engine.run(file)

      parameters.outFile.get().asFile
        .createSafely("${result.newText.hashCode()}")
    }
  }
}
